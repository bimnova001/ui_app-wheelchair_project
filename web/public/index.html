<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>ROS2 Web Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    /* ...ใช้ style เดิมของคุณ... */
    #points-list button { margin: 2px 2px 2px 0; padding: 4px 10px; border-radius: 6px; border: none; background: #2a2a50; color: #fff; cursor: pointer; }
    #points-list button.send-btn { background: #2ca32c; }
    #points-list button.del-btn { background: #b71c1c; color: #fff; margin-left: 6px; }
    #points-list button.del-btn:hover { background: #ff5252; }
  </style>
</head>
<body>
  <div id="topbar">
    <label>ROS Bridge WebSocket URL: </label>
    <input id="ros-url" type="text" value="ws://localhost:9090" style="width:280px"/>
    <button id="connect-btn">Connect</button>
    <span id="ros-status" class="status disconnected">Disconnected</span>
  </div>

  <div id="container">
    <div id="left-panel">
      <h3 class="panel-title">Joystick</h3>
      <div id="joystick-area-wrapper">
        <div id="joystick-area"></div>
        <div id="joy-values">
          <span id="joy-lin">Linear: 0.00</span>
          <span id="joy-ang">Angular: 0.00</span>
        </div>
      </div>
      <div id="controls">
        <label>Max Linear m/s: <input id="max-linear" type="number" value="0.20" step="0.01"/></label>
        <label>Max Angular rad/s: <input id="max-angular" type="number" value="0.7" step="0.01"/></label>
        <button id="stop-btn">STOP</button>
      </div>
      <h3>Battery</h3>
      <div>Battery: <span id="battery">N/A</span></div>
    </div>

    <div id="center-panel">
      <h3>Map (click to add point)</h3>
      <canvas id="map-canvas" width="600" height="600"></canvas>
      <div id="map-info">Map: not loaded</div>
      <div style="margin:10px 0;">
        <button id="save-map-btn">Save Map</button>
        <button id="load-map-btn">Load Map</button>
        <input type="file" id="map-file-input" style="display:none"/>
      </div>
      <h3>Saved Points</h3>
      <div id="points-list"></div>
      <div style="margin-bottom:8px;">
        <button id="save-points-btn">Save Points (JSON)</button>
        <button id="load-points-btn">Load Points (JSON)</button>
        <input type="file" id="points-file-input" style="display:none"/>
      </div>
    </div>

    <div id="right-panel">
      <h3>Camera</h3>
      <img id="camera-img" alt="camera"/>
      <div>
        <label>Camera topic:
          <input id="camera-topic" type="text" value="/camera/image/compressed"/>
        </label>
        <button id="subscribe-camera">Subscribe</button>
      </div>
      <h3>Status Log</h3>
      <pre id="log"></pre>
      <h3>Nav2 Status</h3>
      <div id="nav2-status">Nav2: N/A</div>
    </div>
  </div>

<script>
/* ---------- Globals ---------- */
let ros = null;
let cmdVelTopic = null;
let mapTopic = null;
let cameraTopic = null;
let batteryTopic = null;
let goalTopic = null;
let nav2FeedbackTopic = null;
let nav2ResultTopic = null;

/* ----- UI elements ----- */
const logEl = document.getElementById('log');
const rosStatusEl = document.getElementById('ros-status');
const connectBtn = document.getElementById('connect-btn');
const rosUrlInput = document.getElementById('ros-url');
const nav2Status = document.getElementById('nav2-status');

const saveMapBtn = document.getElementById('save-map-btn');
const loadMapBtn = document.getElementById('load-map-btn');
const mapFileInput = document.getElementById('map-file-input');

const pointsList = document.getElementById('points-list');
const savePointsBtn = document.getElementById('save-points-btn');
const loadPointsBtn = document.getElementById('load-points-btn');
const pointsFileInput = document.getElementById('points-file-input');
let savedPoints = [];

/* ---------- LOG LIMIT ---------- */
function log(msg) {
  console.log(msg);
  logEl.textContent += msg + '\n';
  let lines = logEl.textContent.split('\n');
  if (lines.length > 100) lines = lines.slice(lines.length-100);
  logEl.textContent = lines.join('\n');
  logEl.scrollTop = logEl.scrollHeight;
}

/* ---------- Connect to rosbridge ---------- */
connectBtn.addEventListener('click', () => {
  if (ros && ros.isConnected) { disconnectRos(); return; }
  const url = rosUrlInput.value.trim();
  connectRos(url);
});

function connectRos(url) {
  ros = new ROSLIB.Ros({url});
  ros.on('connection', () => {
    rosStatusEl.textContent = 'Connected';
    rosStatusEl.className = 'status connected';
    log('Connected to rosbridge at ' + url);
    setupTopics();
    initJoystick();
  });
  ros.on('close', () => {
    rosStatusEl.textContent = 'Disconnected';
    rosStatusEl.className = 'status disconnected';
    log('ROS connection closed');
  });
  ros.on('error', (err) => {
    rosStatusEl.textContent = 'Error';
    rosStatusEl.className = 'status error';
    log('ROS connection error: ' + err);
  });
}

function disconnectRos() {
  if (ros) ros.close();
  ros = null;
  rosStatusEl.textContent = 'Disconnected';
  rosStatusEl.className = 'status disconnected';
}

/* ---------- Topics & publishers ---------- */
function setupTopics() {
  // สร้าง topics หลังจาก ros connected เสมอ
  cmdVelTopic = new ROSLIB.Topic({
    ros: ros,
    name: '/cmd_vel',
    // สำหรับ ROS2 + ros2-web-bridge ให้ใช้รูปแบบ package/msg/Message
    messageType: 'geometry_msgs/msg/Twist'
  });

  // map (ROS2)
  mapTopic = new ROSLIB.Topic({
    ros: ros,
    name: '/map',
    messageType: 'nav_msgs/msg/OccupancyGrid'
  });
  mapTopic.subscribe(onMap);

  // battery (ROS2)
  batteryTopic = new ROSLIB.Topic({
    ros: ros,
    name: '/battery_state',
    messageType: 'sensor_msgs/msg/BatteryState'
  });
  batteryTopic.subscribe(onBattery);

  // Nav2 feedback/result (ROS2 action topics from ros2-web-bridge)
  nav2FeedbackTopic = new ROSLIB.Topic({
    ros: ros,
    name: '/navigate_to_pose/_action/feedback',
    messageType: 'nav2_msgs/action/NavigateToPose_FeedbackMessage'
  });
  nav2FeedbackTopic.subscribe(onNav2Feedback);

  nav2ResultTopic = new ROSLIB.Topic({
    ros: ros,
    name: '/navigate_to_pose/_action/result',
    messageType: 'nav2_msgs/action/NavigateToPose_Result'
  });
  nav2ResultTopic.subscribe(onNav2Result);

  log('Topics created with ROS2 message types. cmd_vel ready.');
}

function onNav2Feedback(msg) {
  if (msg && msg.feedback && msg.feedback.current_pose) {
    const p = msg.feedback.current_pose.pose.position;
    nav2Status.textContent = `Nav2: Moving to goal (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`;
  } else {
    nav2Status.textContent = "Nav2: Moving...";
  }
}
function onNav2Result(msg) {
  if (msg && msg.result && msg.result.result == 0) {
    nav2Status.textContent = "Nav2: Goal reached!";
  } else if (msg && msg.result && msg.result.result == 2) {
    nav2Status.textContent = "Nav2: Goal canceled.";
  } else {
    nav2Status.textContent = "Nav2: Navigation finished.";
  }
}

/* ---------- Joystick (nipplejs) ---------- */
const joystickArea = document.getElementById('joystick-area');
const maxLinearInput = document.getElementById('max-linear');
const maxAngularInput = document.getElementById('max-angular');
const stopBtn = document.getElementById('stop-btn');

const manager = nipplejs.create({
  zone: joystickArea,
  mode: 'static',
  position: {left: '50%', top: '50%'},
  color: 'lightblue',
  size: 180
});

let joystickVector = {x:0, y:0};

manager.on('move', (evt, data) => {
  if (!data || !data.vector) return;
  joystickVector.x = data.vector.x;
  joystickVector.y = data.vector.y;
});
manager.on('end', () => {
  joystickVector.x = 0;
  joystickVector.y = 0;
  publishTwist(0,0);
});

function publishTwist(linear, angular) {
  if (!ros || !cmdVelTopic) return;
  const twist = new ROSLIB.Message({
    linear: {x: linear, y:0, z:0},
    angular: {x:0, y:0, z: angular}
  });
  cmdVelTopic.publish(twist);
  log(`Publish /cmd_vel: linear=${linear.toFixed(2)} angular=${angular.toFixed(2)}`);
}

function updateJoyValues(lin, ang) {
  document.getElementById('joy-lin').textContent = `Linear: ${lin.toFixed(2)}`;
  document.getElementById('joy-ang').textContent = `Angular: ${ang.toFixed(2)}`;
}
setInterval(()=>{
  const maxLinear = parseFloat(maxLinearInput.value) || 0.2;
  const maxAngular = parseFloat(maxAngularInput.value) || 0.7;
  const linear = (-joystickVector.y) * maxLinear;
  const angular = (-joystickVector.x) * maxAngular;
  const lin = Math.abs(linear) < 0.02 ? 0 : linear;
  const ang = Math.abs(angular) < 0.02 ? 0 : angular;
  publishTwist(lin, ang);
  updateJoyValues(lin, ang);
}, 80);

stopBtn.addEventListener('click', () => {
  publishTwist(0,0);
});

/* ---------- Map rendering ---------- */
const mapCanvas = document.getElementById('map-canvas');
const mapCtx = mapCanvas.getContext('2d');
let lastMap = null;

function onMap(msg) {
  try {
    const width = msg.info.width;
    const height = msg.info.height;
    const resolution = msg.info.resolution;
    const origin = msg.info.origin;
    const data = msg.data;

    lastMap = {width, height, resolution, origin, data};

    const canvasW = mapCanvas.width;
    const canvasH = mapCanvas.height;

    const imageData = mapCtx.createImageData(width, height);
    for (let i=0;i<width*height;i++){
      const v = data[i];
      let color = 127;
      if (v === -1) color = 127;
      else if (v >= 50) color = 0;
      else color = 255;
      imageData.data[i*4+0] = color;
      imageData.data[i*4+1] = color;
      imageData.data[i*4+2] = color;
      imageData.data[i*4+3] = 255;
    }
    const tmp = document.createElement('canvas');
    tmp.width = width;
    tmp.height = height;
    tmp.getContext('2d').putImageData(imageData,0,0);

    mapCtx.clearRect(0,0,canvasW,canvasH);
    mapCtx.drawImage(tmp, 0,0, canvasW, canvasH);

    document.getElementById('map-info').textContent = `Map ${width}x${height}, res=${resolution.toFixed(3)} m/px`;
    log('Received map, drawn.');
  } catch (e) {
    console.error(e);
    log('Error drawing map: ' + e);
  }
}

/* ---------- Save/Load Map ---------- */
saveMapBtn.onclick = function() {
  if (!lastMap) {
    alert("ยังไม่มีข้อมูล map");
    return;
  }
  const name = prompt("ตั้งชื่อ map ที่จะ save (เช่น mymap):");
  if (!name) return;

  let pgm = `P2\n${lastMap.width} ${lastMap.height}\n255\n`;
  for (let i = 0; i < lastMap.data.length; i++) {
    let v = lastMap.data[i];
    let val = 205; // unknown
    if (v === 0) val = 254; // free
    else if (v > 50) val = 0; // occupied
    pgm += val + (i % lastMap.width === lastMap.width - 1 ? '\n' : ' ');
  }
  const pgmBlob = new Blob([pgm], {type: 'image/x-portable-graymap'});
  const pgmUrl = URL.createObjectURL(pgmBlob);

  const yaml =
    `image: ${name}.pgm
resolution: ${lastMap.resolution}
origin: [${lastMap.origin.position.x}, ${lastMap.origin.position.y}, 0.0]
negate: 0
occupied_thresh: 0.65
free_thresh: 0.196
`;
  const yamlBlob = new Blob([yaml], {type: 'text/yaml'});
  const yamlUrl = URL.createObjectURL(yamlBlob);

  const a1 = document.createElement('a');
  a1.href = pgmUrl;
  a1.download = name + '.pgm';
  a1.click();

  const a2 = document.createElement('a');
  a2.href = yamlUrl;
  a2.download = name + '.yaml';
  a2.click();

  log(`ดาวน์โหลด map: ${name}.pgm และ ${name}.yaml`);
};

loadMapBtn.onclick = function() {
  mapFileInput.accept = ".yaml,.pgm,.png";
  mapFileInput.click();
};
mapFileInput.onchange = function(e) {
  const file = e.target.files[0];
  if (!file) return;
  if (file.name.endsWith('.yaml')) {
    const reader = new FileReader();
    reader.onload = function(ev) {
      try {
        const yaml = ev.target.result;
        const width = parseInt(yaml.match(/width:\s*(\d+)/)?.[1] || "600");
        const height = parseInt(yaml.match(/height:\s*(\d+)/)?.[1] || "600");
        const resolution = parseFloat(yaml.match(/resolution:\s*([\d\.]+)/)[1]);
        const origin = yaml.match(/origin:\s*\[([^\]]+)\]/)[1].split(',').map(Number);
        alert("โหลด yaml สำเร็จ: width="+width+" height="+height+" res="+resolution);
      } catch(e) {
        alert("โหลด yaml ไม่สำเร็จ: "+e);
      }
    };
    reader.readAsText(file);
  } else if (file.name.endsWith('.pgm') || file.name.endsWith('.png')) {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = function() {
      mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
      mapCtx.drawImage(img, 0,0, mapCanvas.width, mapCanvas.height);
      log('แสดง map จากไฟล์ภาพ');
    };
    img.src = url;
  }
};

/* ---------- Saved Points (JSON) ---------- */
function savePointsToLocal() {
  localStorage.setItem('ros2_points', JSON.stringify(savedPoints));
}
function loadPointsFromLocal() {
  const data = localStorage.getItem('ros2_points');
  if (data) {
    savedPoints = JSON.parse(data);
    renderPoints();
  }
}
window.addEventListener('DOMContentLoaded', loadPointsFromLocal);

savePointsBtn.onclick = function() {
  const blob = new Blob([JSON.stringify(savedPoints, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'points.json';
  a.click();
};
loadPointsBtn.onclick = function() {
  pointsFileInput.accept = ".json";
  pointsFileInput.click();
};
pointsFileInput.onchange = function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      savedPoints = JSON.parse(ev.target.result);
      renderPoints();
      savePointsToLocal();
      log('Loaded points from file.');
    } catch (err) {
      alert('โหลดไฟล์ points.json ไม่สำเร็จ');
    }
  };
  reader.readAsText(file);
};

function renderPoints(){
  pointsList.innerHTML = '';
  if (savedPoints.length === 0) {
    pointsList.textContent = 'No points yet';
    return;
  }
  savedPoints.forEach((pt, idx) => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '2px';

    const label = document.createElement('span');
    label.textContent = `${pt.name} (${pt.map_x.toFixed(2)},${pt.map_y.toFixed(2)})`;
    label.style.flex = '1';
    row.appendChild(label);

    const sendBtn = document.createElement('button');
    sendBtn.textContent = 'ส่งไป Nav2';
    sendBtn.className = 'send-btn';
    sendBtn.onclick = ()=>{
      const poseMsg = new ROSLIB.Message({
        header: { frame_id: "map" },
        pose: {
          position: { x: pt.map_x, y: pt.map_y, z: 0.0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 }
        }
      });
      if (goalTopic) goalTopic.publish(poseMsg);
      log(`Sent point: ${pt.name} (${pt.map_x.toFixed(2)}, ${pt.map_y.toFixed(2)})`);
    };
    row.appendChild(sendBtn);

    const del = document.createElement('button');
    del.textContent = '✕';
    del.className = 'del-btn';
    del.onclick = ()=>{
      savedPoints.splice(idx,1);
      renderPoints();
      savePointsToLocal();
    };
    row.appendChild(del);

    pointsList.appendChild(row);
  });
}

/* ---------- Map click: add point ---------- */
mapCanvas.addEventListener('click', (ev)=>{
  if (!lastMap || !ros || !goalTopic) {
    log('Map not available or not connected.');
    return;
  }
  const rect = mapCanvas.getBoundingClientRect();
  const xcanvas = ev.clientX - rect.left;
  const ycanvas = ev.clientY - rect.top;
  const mx_px = Math.floor((xcanvas / mapCanvas.width) * lastMap.width);
  const my_px = Math.floor(((mapCanvas.height - ycanvas) / mapCanvas.height) * lastMap.height);
  const map_x = lastMap.origin.position.x + mx_px * lastMap.resolution;
  const map_y = lastMap.origin.position.y + my_px * lastMap.resolution;
  const name = prompt("ตั้งชื่อจุดนี้:");
  if (!name) return;
  savedPoints.push({name, map_x, map_y});
  savePointsToLocal();
  renderPoints();
});

/* ---------- Camera subscription ---------- */
const cameraImg = document.getElementById('camera-img');
const cameraTopicInput = document.getElementById('camera-topic');
const subscribeCameraBtn = document.getElementById('subscribe-camera');
let cameraSubscriber = null;

subscribeCameraBtn.addEventListener('click', ()=>{
  if (!ros) { log('ROS not connected'); return; }
  const topicName = cameraTopicInput.value.trim();
  if (!topicName) return;
  if (cameraSubscriber) cameraSubscriber.unsubscribe();
  cameraSubscriber = new ROSLIB.Topic({
    ros,
    name: topicName,
    messageType: topicName.includes('compressed') ? 'sensor_msgs/CompressedImage' : 'sensor_msgs/Image'
  });
  cameraSubscriber.subscribe(onCameraMessage);
  log('Subscribed to camera topic: ' + topicName);
});

function onCameraMessage(msg) {
  if (msg.data) {
    cameraImg.src = 'data:image/jpeg;base64,' + msg.data;
  }
}

function initJoystick() {
  // ถ้า element ยังไม่มีขนาด ควรรอ DOM load หรือ setTimeout สั้น ๆ ก่อนสร้าง
  const zone = document.getElementById('joystick-area');
  // Defensive: ถ้า zone ขนาด 0 ให้รอ 200ms แล้วลองอีกที
  if (zone.clientWidth === 0 || zone.clientHeight === 0) {
    setTimeout(initJoystick, 200);
    return;
  }

  const manager = nipplejs.create({
    zone: zone,
    mode: 'static',
    position: { left: '50%', top: '50%' }, // acceptable
    size: 180
  });

  let joystickVector = { x: 0, y: 0 };

  manager.on('move', (evt, data) => {
    if (!data || !data.vector) return;
    joystickVector.x = data.vector.x;
    joystickVector.y = data.vector.y;
  });
  manager.on('end', () => {
    joystickVector.x = 0; joystickVector.y = 0;
    publishTwist(0, 0); // stop
  });

  // publish loop (throttle)
  setInterval(() => {
    const maxLinear = parseFloat(document.getElementById('max-linear').value) || 0.2;
    const maxAngular = parseFloat(document.getElementById('max-angular').value) || 0.7;
    const linear = (-joystickVector.y) * maxLinear;
    const angular = (-joystickVector.x) * maxAngular;
    // small deadzone
    const lin = Math.abs(linear) < 0.02 ? 0 : linear;
    const ang = Math.abs(angular) < 0.02 ? 0 : angular;
    publishTwist(lin, ang);
    updateJoyValues(lin, ang);
  }, 80);
}


/* ---------- Battery subscription ---------- */
function onBattery(msg) {
  let percent = null;
  if (typeof msg.percentage === 'number') {
    if (msg.percentage > 1.5) percent = msg.percentage.toFixed(1) + '%';
    else percent = (msg.percentage*100).toFixed(1) + '%';
  }
  else if (msg.voltage) percent = `${msg.voltage.toFixed(2)}V`;
  else percent = JSON.stringify(msg).slice(0,40);
  document.getElementById('battery').textContent = percent;
}

/* ---------- init UI ---------- */
renderPoints();
log('UI ready. Enter rosbridge ws url and press Connect.');
</script>
</body>
</html>