<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>ROS2 Web Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="style.css">
  <!-- roslibjs -->
  <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
  <!-- nipplejs for joystick -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    body { background: linear-gradient(135deg, #18191c 0%, #232323 100%); color: #f2f2f2; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; }
    #topbar { background: #b71c1c; padding: 24px 0 16px 0; text-align: center; box-shadow: 0 4px 16px #0008; }
    #topbar label { font-weight: 500; }
    #topbar input { padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background:#222; color:#fff; }
    #topbar button { padding: 6px 12px; border:none; border-radius:6px; background:#2a2a50; color:#fff; cursor:pointer; transition: 0.2s; }
    #topbar button:hover { background:#3a3a80; }
    .status { display:inline-block; margin-left:16px; padding:4px 14px; border-radius:8px; font-weight:600; }
    .status.connected { background:#0b3d3d; color:#bff; }
    .status.disconnected { background:#3d0b0b; color:#fdd; }
    .status.error { background:#440000; color:#f99; }
    #container { display: flex; flex-wrap: wrap; gap: 24px; justify-content: center; margin: 32px auto 0 auto; max-width: 1400px; }
    #left-panel, #center-panel, #right-panel { background: #232323e6; border-radius: 18px; box-shadow: 0 8px 32px #0007; padding: 24px 18px 18px 18px; min-width: 260px; }
    #left-panel { flex: 1 1 280px; max-width: 320px; }
    #center-panel { flex: 2 1 640px; max-width: 700px; align-items: center; }
    #right-panel { flex: 1 1 320px; max-width: 360px; }
    h3 { color: #ff5252; margin-top: 12px; font-size: 1.2rem; font-weight: 600; }
    #joystick-area { width: 180px; height: 180px; margin: 0 auto 12px auto; }
    #controls label { display:block; margin: 8px 0 4px 0; }
    #controls input { width: 80px; }
    #controls button { padding: 6px 12px; border-radius:6px; border:none; background:#2a1a1a; color:#fff; cursor:pointer; transition:0.2s; }
    #controls button:hover { background:#3a2a2a; transform: scale(1.05); }
    #map-canvas { border: 2px solid #444; border-radius: 12px; background: #111; margin: 8px 0 8px 0; box-shadow: 0 2px 8px #0008; }
    #goals-list button { margin: 2px 2px 2px 0; padding: 4px 10px; border-radius: 6px; border: none; background: #2a2a50; color: #fff; cursor: pointer; transition: background 0.2s, transform 0.2s; }
    #goals-list button:hover { background: #3a3a80; transform: scale(1.04); }
    #goals-list .del-btn { background: #b71c1c; color: #fff; margin-left: 6px; }
    #goals-list .del-btn:hover { background: #ff5252; }
    #camera-img { width: 100%; max-width: 640px; height: 360px; background:#000; border-radius: 10px; margin-bottom: 8px; }
    #log { height:200px; overflow:auto; background:#111; color:#0f0; padding:8px; border-radius: 8px; }
    @media (max-width: 1100px) { #container { flex-direction: column; align-items: stretch; } }
    @media (max-width: 700px) { #left-panel, #center-panel, #right-panel { min-width: unset; max-width: unset; padding: 12px 4vw; } #map-canvas { width: 98vw; height: 60vw; } }
    .goal-anim { animation: goalFlash 0.7s; }
    @keyframes goalFlash { 0%{box-shadow:0 0 0 #fff;} 50%{box-shadow:0 0 24px #ff0;} 100%{box-shadow:0 0 0 #fff;} }
  </style>
</head>
<body>
  <div id="topbar">
    <label>ROS Bridge WebSocket URL: </label>
    <input id="ros-url" type="text" value="ws://localhost:9090" style="width:280px"/>
    <button id="connect-btn">Connect</button>
    <span id="ros-status" class="status disconnected">Disconnected</span>
  </div>

  <div id="container">
    <div id="left-panel">
      <h3 class="panel-title">Joystick</h3>
      <div id="joystick-area-wrapper">
        <div id="joystick-area"></div>
        <div id="joy-values">
          <span id="joy-lin">Linear: 0.00</span>
          <span id="joy-ang">Angular: 0.00</span>
        </div>
      </div>
      <div id="controls">
        <label>Max Linear m/s: <input id="max-linear" type="number" value="0.20" step="0.01"/></label>
        <label>Max Angular rad/s: <input id="max-angular" type="number" value="0.7" step="0.01"/></label>
        <button id="stop-btn">STOP</button>
      </div>

      <h3>Battery</h3>
      <div>Battery: <span id="battery">N/A</span></div>

      <h3>Saved Goals</h3>
      <div id="goals-list">No goals yet</div>
      <button id="clear-goals">Clear saved goals</button>
      <button id="save-goals">Save goals</button>
      <button id="load-goals">Load goals</button>
    </div>

    <div id="center-panel">
      <h3>Map (click to publish goal)</h3>
      <canvas id="map-canvas" width="600" height="600"></canvas>
      <div id="map-info">Map: not loaded</div>
    </div>

    <div id="right-panel">
      <h3>Camera</h3>
      <img id="camera-img" alt="camera"/>
      <div>
        <label>Camera topic:
          <input id="camera-topic" type="text" value="/camera/image/compressed"/>
        </label>
        <button id="subscribe-camera">Subscribe</button>
      </div>

      <h3>Status Log</h3>
      <pre id="log"></pre>
    </div>
  </div>

<script>
/* ---------- Globals ---------- */
let ros = null;
let cmdVelTopic = null;
let mapTopic = null;
let cameraTopic = null;
let batteryTopic = null;
let goalTopic = null;

/* ----- UI elements ----- */
const logEl = document.getElementById('log');
const rosStatusEl = document.getElementById('ros-status');
const connectBtn = document.getElementById('connect-btn');
const rosUrlInput = document.getElementById('ros-url');

function log(msg) {
  console.log(msg);
  logEl.textContent += msg + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}

/* ---------- Connect to rosbridge ---------- */
connectBtn.addEventListener('click', () => {
  if (ros && ros.isConnected) { disconnectRos(); return; }
  const url = rosUrlInput.value.trim();
  connectRos(url);
});

function connectRos(url) {
  ros = new ROSLIB.Ros({url});
  ros.on('connection', () => {
    rosStatusEl.textContent = 'Connected';
    rosStatusEl.className = 'status connected';
    log('Connected to rosbridge at ' + url);
    setupTopics();
  });
  ros.on('close', () => {
    rosStatusEl.textContent = 'Disconnected';
    rosStatusEl.className = 'status disconnected';
    log('ROS connection closed');
  });
  ros.on('error', (err) => {
    rosStatusEl.textContent = 'Error';
    rosStatusEl.className = 'status error';
    log('ROS connection error: ' + err);
  });
}

function disconnectRos() {
  if (ros) ros.close();
  ros = null;
  rosStatusEl.textContent = 'Disconnected';
  rosStatusEl.className = 'status disconnected';
}

/* ---------- Topics & publishers ---------- */
function setupTopics() {
  // cmd_vel publisher
  cmdVelTopic = new ROSLIB.Topic({
    ros, name: '/cmd_vel', messageType: 'geometry_msgs/Twist'
  });

  // goal publisher (PoseStamped)
  goalTopic = new ROSLIB.Topic({
    ros, name: '/goal_pose', messageType: 'geometry_msgs/PoseStamped'
  });

  // map subscriber
  mapTopic = new ROSLIB.Topic({
    ros, name: '/map', messageType: 'nav_msgs/OccupancyGrid'
  });
  mapTopic.subscribe(onMap);

  // battery subscriber (try /battery_state or /battery)
  batteryTopic = new ROSLIB.Topic({
    ros, name: '/battery_state', messageType: 'sensor_msgs/BatteryState'
  });
  batteryTopic.subscribe(onBattery);

  log('Topics set up (cmd_vel, goal_pose, map, battery_state).');
}

/* ---------- Joystick (nipplejs) ---------- */
const joystickArea = document.getElementById('joystick-area');
const maxLinearInput = document.getElementById('max-linear');
const maxAngularInput = document.getElementById('max-angular');
const stopBtn = document.getElementById('stop-btn');

const manager = nipplejs.create({
  zone: joystickArea,
  mode: 'static',
  position: {left: '50%', top: '50%'},
  color: 'lightblue',
  size: 180
});

let joystickVector = {x:0, y:0};

manager.on('move', (evt, data) => {
  if (!data || !data.vector) return;
  joystickVector.x = data.vector.x; // horizontal (-1..1)
  joystickVector.y = data.vector.y; // vertical (-1..1), up negative?
});
manager.on('end', () => {
  joystickVector.x = 0;
  joystickVector.y = 0;
  publishTwist(0,0);
});

function publishTwist(linear, angular) {
  if (!ros || !cmdVelTopic) return;
  const twist = new ROSLIB.Message({
    linear: {x: linear, y:0, z:0},
    angular: {x:0, y:0, z: angular}
  });
  cmdVelTopic.publish(twist);
}

function updateJoyValues(lin, ang) {
  document.getElementById('joy-lin').textContent = `Linear: ${lin.toFixed(2)}`;
  document.getElementById('joy-ang').textContent = `Angular: ${ang.toFixed(2)}`;
}
setInterval(()=>{
  const maxLinear = parseFloat(maxLinearInput.value) || 0.2;
  const maxAngular = parseFloat(maxAngularInput.value) || 0.7;
  const linear = (-joystickVector.y) * maxLinear;
  const angular = (-joystickVector.x) * maxAngular;
  const lin = Math.abs(linear) < 0.02 ? 0 : linear;
  const ang = Math.abs(angular) < 0.02 ? 0 : angular;
  publishTwist(lin, ang);
  updateJoyValues(lin, ang);
}, 80);

stopBtn.addEventListener('click', () => {
  publishTwist(0,0);
});

/* ---------- Map rendering ---------- */
const mapCanvas = document.getElementById('map-canvas');
const mapCtx = mapCanvas.getContext('2d');
let lastMap = null;

function onMap(msg) {
  try {
    const width = msg.info.width;
    const height = msg.info.height;
    const resolution = msg.info.resolution;
    const origin = msg.info.origin;
    const data = msg.data;

    lastMap = {width, height, resolution, origin, data};

    const canvasW = mapCanvas.width;
    const canvasH = mapCanvas.height;
    const sx = canvasW / width;
    const sy = canvasH / height;

    const imageData = mapCtx.createImageData(width, height);
    for (let i=0;i<width*height;i++){
      const v = data[i];
      let color = 127;
      if (v === -1) color = 127;
      else if (v >= 50) color = 0;
      else color = 255;
      imageData.data[i*4+0] = color;
      imageData.data[i*4+1] = color;
      imageData.data[i*4+2] = color;
      imageData.data[i*4+3] = 255;
    }
    const tmp = document.createElement('canvas');
    tmp.width = width;
    tmp.height = height;
    tmp.getContext('2d').putImageData(imageData,0,0);

    mapCtx.clearRect(0,0,canvasW,canvasH);
    mapCtx.drawImage(tmp, 0,0, canvasW, canvasH);

    document.getElementById('map-info').textContent = `Map ${width}x${height}, res=${resolution.toFixed(3)} m/px`;
    log('Received map, drawn.');
  } catch (e) {
    console.error(e);
    log('Error drawing map: ' + e);
  }
}

mapCanvas.addEventListener('click', (ev)=>{
  if (!lastMap || !ros || !goalTopic) {
    log('Map not available or not connected.');
    return;
  }
  const rect = mapCanvas.getBoundingClientRect();
  const xcanvas = ev.clientX - rect.left;
  const ycanvas = ev.clientY - rect.top;
  const mx_px = Math.floor((xcanvas / mapCanvas.width) * lastMap.width);
  const my_px = Math.floor(((mapCanvas.height - ycanvas) / mapCanvas.height) * lastMap.height);
  const map_x = lastMap.origin.position.x + mx_px * lastMap.resolution;
  const map_y = lastMap.origin.position.y + my_px * lastMap.resolution;
  const poseMsg = new ROSLIB.Message({
    header: { frame_id: "map" },
    pose: {
      position: { x: map_x, y: map_y, z: 0.0 },
      orientation: { x: 0, y: 0, z: 0, w: 1 }
    }
  });
  goalTopic.publish(poseMsg);
  log(`Published goal_pose: x=${map_x.toFixed(2)}, y=${map_y.toFixed(2)}`);
  addGoal({name: `Goal ${Date.now()}`, map_x, map_y});
  // Animation
  mapCanvas.classList.add('goal-anim');
  setTimeout(()=>mapCanvas.classList.remove('goal-anim'), 700);
});

/* ---------- Goals list UI ---------- */
const goalsList = document.getElementById('goals-list');
const clearGoalsBtn = document.getElementById('clear-goals');
const saveGoalsBtn = document.getElementById('save-goals');
const loadGoalsBtn = document.getElementById('load-goals');
let savedGoals = [];

function addGoal(g) {
  savedGoals.push(g);
  renderGoals();
}

function renderGoals(){
  goalsList.innerHTML = '';
  if (savedGoals.length === 0) {
    goalsList.textContent = 'No goals yet';
    return;
  }
  savedGoals.forEach((g, idx) => {
    const btn = document.createElement('button');
    btn.textContent = `${g.name} (${g.map_x.toFixed(2)},${g.map_y.toFixed(2)})`;
    btn.onclick = ()=>{
      const poseMsg = new ROSLIB.Message({
        header: { frame_id: "map" },
        pose: {
          position: { x: g.map_x, y: g.map_y, z: 0.0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 }
        }
      });
      if (goalTopic) goalTopic.publish(poseMsg);
      log(`Sent saved goal: x=${g.map_x.toFixed(2)}, y=${g.map_y.toFixed(2)}`);
      mapCanvas.classList.add('goal-anim');
      setTimeout(()=>mapCanvas.classList.remove('goal-anim'), 700);
    };
    goalsList.appendChild(btn);
    const del = document.createElement('button');
    del.textContent = '✕';
    del.className = 'del-btn';
    del.onclick = ()=>{
      savedGoals.splice(idx,1);
      renderGoals();
    };
    goalsList.appendChild(del);
    goalsList.appendChild(document.createElement('br'));
  });
}

clearGoalsBtn.addEventListener('click', ()=>{
  savedGoals = [];
  renderGoals();
});

function saveGoalsToLocal() {
  localStorage.setItem('ros2_goals', JSON.stringify(savedGoals));
  log('Goals saved to localStorage.');
}
function loadGoalsFromLocal() {
  const data = localStorage.getItem('ros2_goals');
  if (data) {
    savedGoals = JSON.parse(data);
    renderGoals();
    log('Goals loaded from localStorage.');
  }
}

saveGoalsBtn.addEventListener('click', saveGoalsToLocal);
loadGoalsBtn.addEventListener('click', loadGoalsFromLocal);

/* ---------- Camera subscription ---------- */
const cameraImg = document.getElementById('camera-img');
const cameraTopicInput = document.getElementById('camera-topic');
const subscribeCameraBtn = document.getElementById('subscribe-camera');
let cameraSubscriber = null;

subscribeCameraBtn.addEventListener('click', ()=>{
  if (!ros) { log('ROS not connected'); return; }
  const topicName = cameraTopicInput.value.trim();
  if (!topicName) return;
  if (cameraSubscriber) cameraSubscriber.unsubscribe();
  cameraSubscriber = new ROSLIB.Topic({
    ros,
    name: topicName,
    messageType: topicName.includes('compressed') ? 'sensor_msgs/CompressedImage' : 'sensor_msgs/Image'
  });
  cameraSubscriber.subscribe(onCameraMessage);
  log('Subscribed to camera topic: ' + topicName);
});

function onCameraMessage(msg) {
  if (msg.format || msg.data) {
    cameraImg.src = 'data:image/jpeg;base64,' + msg.data;
  } else if (msg.data && msg.data.length) {
    if (msg.data) cameraImg.src = 'data:image/jpeg;base64,' + msg.data;
  }
}

/* ---------- Battery subscription ---------- */
function onBattery(msg) {
  let percent = null;
  if (typeof msg.percentage === 'number') percent = (msg.percentage*100).toFixed(1) + '%';
  else if (msg.voltage) percent = `${msg.voltage.toFixed(2)}V`;
  else percent = JSON.stringify(msg).slice(0,40);
  document.getElementById('battery').textContent = percent;
}

/* ---------- init UI ---------- */
renderGoals();
log('UI ready. Enter rosbridge ws url and press Connect.');
</script>
</body>
</html>
