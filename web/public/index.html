<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>ROS2 Web Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="style.css">
  <!-- roslibjs -->
  <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
  <!-- nipplejs for joystick -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    body { background: linear-gradient(135deg, #18191c 0%, #232323 100%); color: #f2f2f2; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; }
    #topbar { background: #b71c1c; padding: 24px 0 16px 0; text-align: center; box-shadow: 0 4px 16px #0008; }
    #topbar label { font-weight: 500; }
    #topbar input { padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background:#222; color:#fff; }
    #topbar button { padding: 6px 12px; border:none; border-radius:6px; background:#2a2a50; color:#fff; cursor:pointer; transition: 0.2s; }
    #topbar button:hover { background:#3a3a80; }
    .status { display:inline-block; margin-left:16px; padding:4px 14px; border-radius:8px; font-weight:600; }
    .status.connected { background:#0b3d3d; color:#bff; }
    .status.disconnected { background:#3d0b0b; color:#fdd; }
    .status.error { background:#440000; color:#f99; }
    #container { display: flex; flex-wrap: wrap; gap: 24px; justify-content: center; margin: 32px auto 0 auto; max-width: 1400px; }
    #left-panel, #center-panel, #right-panel { background: #232323e6; border-radius: 18px; box-shadow: 0 8px 32px #0007; padding: 24px 18px 18px 18px; min-width: 260px; }
    #left-panel { flex: 1 1 280px; max-width: 320px; }
    #center-panel { flex: 2 1 640px; max-width: 700px; align-items: center; }
    #right-panel { flex: 1 1 320px; max-width: 360px; }
    h3 { color: #ff5252; margin-top: 12px; font-size: 1.2rem; font-weight: 600; }
    #joystick-area { width: 180px; height: 180px; margin: 0 auto 12px auto; }
    #controls label { display:block; margin: 8px 0 4px 0; }
    #controls input { width: 80px; }
    #controls button { padding: 6px 12px; border-radius:6px; border:none; background:#2a1a1a; color:#fff; cursor:pointer; transition:0.2s; }
    #controls button:hover { background:#3a2a2a; transform: scale(1.05); }
    #map-canvas { border: 2px solid #444; border-radius: 12px; background: #111; margin: 8px 0 8px 0; box-shadow: 0 2px 8px #0008; }
    #goals-list button { margin: 2px 2px 2px 0; padding: 4px 10px; border-radius: 6px; border: none; background: #2a2a50; color: #fff; cursor: pointer; transition: background 0.2s, transform 0.2s; }
    #goals-list button:hover { background: #3a3a80; transform: scale(1.04); }
    #goals-list .del-btn { background: #b71c1c; color: #fff; margin-left: 6px; }
    #goals-list .del-btn:hover { background: #ff5252; }
    #camera-img { width: 100%; max-width: 640px; height: 360px; background:#000; border-radius: 10px; margin-bottom: 8px; }
    #log { height:200px; overflow:auto; background:#111; color:#0f0; padding:8px; border-radius: 8px; }
    @media (max-width: 1100px) { #container { flex-direction: column; align-items: stretch; } }
    @media (max-width: 700px) { #left-panel, #center-panel, #right-panel { min-width: unset; max-width: unset; padding: 12px 4vw; } #map-canvas { width: 98vw; height: 60vw; } }
    .goal-anim { animation: goalFlash 0.7s; }
    @keyframes goalFlash { 0%{box-shadow:0 0 0 #fff;} 50%{box-shadow:0 0 24px #ff0;} 100%{box-shadow:0 0 0 #fff;} }
  </style>
</head>
<body>
  <div id="topbar">
    <label>ROS Bridge WebSocket URL: </label>
    <input id="ros-url" type="text" value="ws://localhost:9090" style="width:280px"/>
    <button id="connect-btn">Connect</button>
    <span id="ros-status" class="status disconnected">Disconnected</span>
  </div>

  <div id="container">
    <div id="left-panel">
      <h3 class="panel-title">Joystick</h3>
      <div id="joystick-area-wrapper">
        <div id="joystick-area"></div>
        <div id="joy-values">
          <span id="joy-lin">Linear: 0.00</span>
          <span id="joy-ang">Angular: 0.00</span>
        </div>
      </div>
      <div id="controls">
        <label>Max Linear m/s: <input id="max-linear" type="number" value="0.20" step="0.01"/></label>
        <label>Max Angular rad/s: <input id="max-angular" type="number" value="0.7" step="0.01"/></label>
        <button id="stop-btn">STOP</button>
      </div>

      <h3>Battery</h3>
      <div>Battery: <span id="battery">N/A</span></div>

      <h3>Saved Goals</h3>
      <div id="goals-list">No goals yet</div>
      <button id="clear-goals">Clear saved goals</button>
      <button id="save-goals">Save goals</button>
      <button id="load-goals">Load goals</button>
    </div>

    <div id="center-panel">
      <h3>Map (click to publish goal)</h3>
      <canvas id="map-canvas" width="600" height="600"></canvas>
      <div id="map-info">Map: not loaded</div>
      <div style="margin:10px 0;">
        <button id="save-map-btn">Save Map</button>
        <button id="load-map-btn">Load Map</button>
        <input type="file" id="map-file-input" style="display:none"/>
      </div>
      <div id="points-list"></div>
    </div>

    <div id="right-panel">
      <h3>Camera</h3>
      <img id="camera-img" alt="camera"/>
      <div>
        <label>Camera topic:
          <input id="camera-topic" type="text" value="/camera/image/compressed"/>
        </label>
        <button id="subscribe-camera">Subscribe</button>
      </div>

      <h3>Status Log</h3>
      <pre id="log"></pre>

      <h3>Nav2 Status</h3>
      <div id="nav2-status">Nav2: N/A</div>
    </div>
  </div>

<script>
/* ---------- Globals ---------- */
let ros = null;
let cmdVelTopic = null;
let mapTopic = null;
let cameraTopic = null;
let batteryTopic = null;
let goalTopic = null;
let nav2FeedbackTopic = null;
let nav2ResultTopic = null;

/* ----- UI elements ----- */
const logEl = document.getElementById('log');
const rosStatusEl = document.getElementById('ros-status');
const connectBtn = document.getElementById('connect-btn');
const rosUrlInput = document.getElementById('ros-url');
const nav2Status = document.getElementById('nav2-status');

const saveMapBtn = document.getElementById('save-map-btn');
const loadMapBtn = document.getElementById('load-map-btn');
const mapFileInput = document.getElementById('map-file-input');
const pointsList = document.getElementById('points-list');
let mapPoints = []; // [{name, map_x, map_y, px, py}]

// --- LOG LIMIT ---
function log(msg) {
  console.log(msg);
  logEl.textContent += msg + '\n';
  // Limit log lines
  let lines = logEl.textContent.split('\n');
  if (lines.length > 100) lines = lines.slice(lines.length-100);
  logEl.textContent = lines.join('\n');
  logEl.scrollTop = logEl.scrollHeight;
}

/* ---------- Connect to rosbridge ---------- */
connectBtn.addEventListener('click', () => {
  if (ros && ros.isConnected) { disconnectRos(); return; }
  const url = rosUrlInput.value.trim();
  connectRos(url);
});

function connectRos(url) {
  ros = new ROSLIB.Ros({url});
  ros.on('connection', () => {
    rosStatusEl.textContent = 'Connected';
    rosStatusEl.className = 'status connected';
    log('Connected to rosbridge at ' + url);
    setupTopics();
  });
  ros.on('close', () => {
    rosStatusEl.textContent = 'Disconnected';
    rosStatusEl.className = 'status disconnected';
    log('ROS connection closed');
  });
  ros.on('error', (err) => {
    rosStatusEl.textContent = 'Error';
    rosStatusEl.className = 'status error';
    log('ROS connection error: ' + err);
  });
}

function disconnectRos() {
  if (ros) ros.close();
  ros = null;
  rosStatusEl.textContent = 'Disconnected';
  rosStatusEl.className = 'status disconnected';
}

/* ---------- Topics & publishers ---------- */
function setupTopics() {
  // cmd_vel publisher
  cmdVelTopic = new ROSLIB.Topic({
    ros, name: '/cmd_vel', messageType: 'geometry_msgs/Twist'
  });

  // goal publisher (PoseStamped)
  goalTopic = new ROSLIB.Topic({
    ros, name: '/goal_pose', messageType: 'geometry_msgs/PoseStamped'
  });

  // map subscriber
  mapTopic = new ROSLIB.Topic({
    ros, name: '/map', messageType: 'nav_msgs/OccupancyGrid'
  });
  mapTopic.subscribe(onMap);

  // battery subscriber (try /battery_state or /battery)
  batteryTopic = new ROSLIB.Topic({
    ros, name: '/battery_state', messageType: 'sensor_msgs/BatteryState'
  });
  batteryTopic.subscribe(onBattery);

  // Nav2 feedback
  nav2FeedbackTopic = new ROSLIB.Topic({
    ros,
    name: '/navigate_to_pose/_action/feedback',
    messageType: 'nav2_msgs/action/NavigateToPose_FeedbackMessage'
  });
  nav2FeedbackTopic.subscribe(onNav2Feedback);

  nav2ResultTopic = new ROSLIB.Topic({
    ros,
    name: '/navigate_to_pose/_action/result',
    messageType: 'nav2_msgs/action/NavigateToPose_Result'
  });
  nav2ResultTopic.subscribe(onNav2Result);

  log('Topics set up (cmd_vel, goal_pose, map, battery_state).');
}

function onNav2Feedback(msg) {
  if (msg && msg.feedback && msg.feedback.current_pose) {
    const p = msg.feedback.current_pose.pose.position;
    nav2Status.textContent = `Nav2: Moving to goal (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`;
  } else {
    nav2Status.textContent = "Nav2: Moving...";
  }
}

function onNav2Result(msg) {
  if (msg && msg.result && msg.result.result == 0) {
    nav2Status.textContent = "Nav2: Goal reached!";
  } else if (msg && msg.result && msg.result.result == 2) {
    nav2Status.textContent = "Nav2: Goal canceled.";
  } else {
    nav2Status.textContent = "Nav2: Navigation finished.";
  }
}

/* ---------- Joystick (nipplejs) ---------- */
const joystickArea = document.getElementById('joystick-area');
const maxLinearInput = document.getElementById('max-linear');
const maxAngularInput = document.getElementById('max-angular');
const stopBtn = document.getElementById('stop-btn');

const manager = nipplejs.create({
  zone: joystickArea,
  mode: 'static',
  position: {left: '50%', top: '50%'},
  color: 'lightblue',
  size: 180
});

let joystickVector = {x:0, y:0};

manager.on('move', (evt, data) => {
  if (!data || !data.vector) return;
  joystickVector.x = data.vector.x; // horizontal (-1..1)
  joystickVector.y = data.vector.y; // vertical (-1..1), up negative?
});
manager.on('end', () => {
  joystickVector.x = 0;
  joystickVector.y = 0;
  publishTwist(0,0);
});

function publishTwist(linear, angular) {
  if (!ros || !cmdVelTopic) return;
  const twist = new ROSLIB.Message({
    linear: {x: linear, y:0, z:0},
    angular: {x:0, y:0, z: angular}
  });
  cmdVelTopic.publish(twist);
  log(`Publish /cmd_vel: linear=${linear.toFixed(2)} angular=${angular.toFixed(2)}`);
}

function updateJoyValues(lin, ang) {
  document.getElementById('joy-lin').textContent = `Linear: ${lin.toFixed(2)}`;
  document.getElementById('joy-ang').textContent = `Angular: ${ang.toFixed(2)}`;
}
setInterval(()=>{
  const maxLinear = parseFloat(maxLinearInput.value) || 0.2;
  const maxAngular = parseFloat(maxAngularInput.value) || 0.7;
  const linear = (-joystickVector.y) * maxLinear;
  const angular = (-joystickVector.x) * maxAngular;
  const lin = Math.abs(linear) < 0.02 ? 0 : linear;
  const ang = Math.abs(angular) < 0.02 ? 0 : angular;
  publishTwist(lin, ang);
  updateJoyValues(lin, ang);
}, 80);

stopBtn.addEventListener('click', () => {
  publishTwist(0,0);
});

// --- SAVE MAP (nav2_map_server) ---
saveMapBtn.onclick = function() {
  const name = prompt("ตั้งชื่อ map ที่จะ save (เช่น mymap):");
  if (!name) return;
  // เรียก ros2 service ผ่าน rosbridge
  const srv = new ROSLIB.Service({
    ros,
    name: '/map_saver/save_map',
    serviceType: 'nav2_msgs/srv/SaveMap'
  });
  const req = new ROSLIB.ServiceRequest({
    map_topic: "/map",
    map_url: name
  });
  srv.callService(req, function(result) {
    log("Save map: " + JSON.stringify(result));
    alert("Save map สำเร็จ: " + name);
  });
};

// --- LOAD MAP (จากไฟล์ yaml+pgm/png) ---
loadMapBtn.onclick = function() {
  mapFileInput.click();
};
mapFileInput.onchange = function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      // สมมติเป็น yaml (หา width, height, resolution, origin)
      const yaml = ev.target.result;
      const width = parseInt(yaml.match(/width:\s*(\d+)/)[1]);
      const height = parseInt(yaml.match(/height:\s*(\d+)/)[1]);
      const resolution = parseFloat(yaml.match(/resolution:\s*([\d\.]+)/)[1]);
      const origin = yaml.match(/origin:\s*\[([^\]]+)\]/)[1].split(',').map(Number);
      // โหลดภาพ map (pgm หรือ png)
      const imgFile = file.name.replace('.yaml', '.png');
      // ให้ user เลือกไฟล์ภาพเอง (หรือจะโหลดอัตโนมัติถ้ามี server)
      alert("โหลด yaml สำเร็จ: width="+width+" height="+height+" res="+resolution);
      // สามารถนำค่าพวกนี้ไปใช้วาด map ต่อได้
    } catch(e) {
      alert("โหลด yaml ไม่สำเร็จ: "+e);
    }
  };
  reader.readAsText(file);
};

// --- MAP POINTS ---
function drawMapPoints() {
  // ลบจุดเดิม
  const old = document.querySelectorAll('.map-point');
  old.forEach(e=>e.remove());
  // วาดจุดใหม่
  if (!lastMap) return;
  mapPoints.forEach(pt=>{
    const px = Math.round((pt.map_x - lastMap.origin.position.x) / lastMap.resolution * mapCanvas.width / lastMap.width);
    const py = Math.round(mapCanvas.height - ((pt.map_y - lastMap.origin.position.y) / lastMap.resolution * mapCanvas.height / lastMap.height));
    const dot = document.createElement('div');
    dot.className = 'map-point';
    dot.style.left = (mapCanvas.offsetLeft+px-7)+'px';
    dot.style.top = (mapCanvas.offsetTop+py-7)+'px';
    dot.title = pt.name;
    dot.style.position = 'absolute';
    dot.style.zIndex = 10;
    document.body.appendChild(dot);
  });
  // แสดงรายชื่อจุด
  pointsList.innerHTML = mapPoints.map((pt,i)=>`<b>${i+1}.</b> ${pt.name} <button onclick="deleteMapPoint(${i})">ลบ</button>`).join('<br>');
}
window.deleteMapPoint = function(idx) {
  mapPoints.splice(idx,1);
  drawMapPoints();
  saveMapPoints();
};
function saveMapPoints() {
  localStorage.setItem('ros2_map_points', JSON.stringify(mapPoints));
}
function loadMapPoints() {
  const data = localStorage.getItem('ros2_map_points');
  if (data) mapPoints = JSON.parse(data);
}
loadMapPoints();

/* ---------- Map rendering ---------- */
const mapCanvas = document.getElementById('map-canvas');
const mapCtx = mapCanvas.getContext('2d');
let lastMap = null;

function onMap(msg) {
  try {
    const width = msg.info.width;
    const height = msg.info.height;
    const resolution = msg.info.resolution;
    const origin = msg.info.origin;
    const data = msg.data;

    lastMap = {width, height, resolution, origin, data};

    const canvasW = mapCanvas.width;
    const canvasH = mapCanvas.height;
    const sx = canvasW / width;
    const sy = canvasH / height;

    const imageData = mapCtx.createImageData(width, height);
    for (let i=0;i<width*height;i++){
      const v = data[i];
      let color = 127;
      if (v === -1) color = 127;
      else if (v >= 50) color = 0;
      else color = 255;
      imageData.data[i*4+0] = color;
      imageData.data[i*4+1] = color;
      imageData.data[i*4+2] = color;
      imageData.data[i*4+3] = 255;
    }
    const tmp = document.createElement('canvas');
    tmp.width = width;
    tmp.height = height;
    tmp.getContext('2d').putImageData(imageData,0,0);

    mapCtx.clearRect(0,0,canvasW,canvasH);
    mapCtx.drawImage(tmp, 0,0, canvasW, canvasH);

    document.getElementById('map-info').textContent = `Map ${width}x${height}, res=${resolution.toFixed(3)} m/px`;
    log('Received map, drawn.');
  } catch (e) {
    console.error(e);
    log('Error drawing map: ' + e);
  }
}

// --- เมื่อคลิก map ให้ตั้งชื่อจุด ---
mapCanvas.addEventListener('click', (ev)=>{
  if (!lastMap || !ros || !goalTopic) {
    log('Map not available or not connected.');
    return;
  }
  const rect = mapCanvas.getBoundingClientRect();
  const xcanvas = ev.clientX - rect.left;
  const ycanvas = ev.clientY - rect.top;
  const mx_px = Math.floor((xcanvas / mapCanvas.width) * lastMap.width);
  const my_px = Math.floor(((mapCanvas.height - ycanvas) / mapCanvas.height) * lastMap.height);
  const map_x = lastMap.origin.position.x + mx_px * lastMap.resolution;
  const map_y = lastMap.origin.position.y + my_px * lastMap.resolution;
  const name = prompt("ตั้งชื่อจุดนี้:");
  if (!name) return;
  mapPoints.push({name, map_x, map_y});
  saveMapPoints();
  drawMapPoints();
  // publish goal เหมือนเดิม
  const poseMsg = new ROSLIB.Message({
    header: { frame_id: "map" },
    pose: {
      position: { x: map_x, y: map_y, z: 0.0 },
      orientation: { x: 0, y: 0, z: 0, w: 1 }
    }
  });
  goalTopic.publish(poseMsg);
  log(`Published goal_pose: x=${map_x.toFixed(2)}, y=${map_y.toFixed(2)}`);
  addGoal({name, map_x, map_y});
  mapCanvas.classList.add('goal-anim');
  setTimeout(()=>mapCanvas.classList.remove('goal-anim'), 700);
});

// --- วาดจุดใหม่ทุกครั้งที่ map เปลี่ยน ---
function onMap(msg) {
  try {
    const width = msg.info.width;
    const height = msg.info.height;
    const resolution = msg.info.resolution;
    const origin = msg.info.origin;
    const data = msg.data;

    lastMap = {width, height, resolution, origin, data};

    const canvasW = mapCanvas.width;
    const canvasH = mapCanvas.height;
    const sx = canvasW / width;
    const sy = canvasH / height;

    const imageData = mapCtx.createImageData(width, height);
    for (let i=0;i<width*height;i++){
      const v = data[i];
      let color = 127;
      if (v === -1) color = 127;
      else if (v >= 50) color = 0;
      else color = 255;
      imageData.data[i*4+0] = color;
      imageData.data[i*4+1] = color;
      imageData.data[i*4+2] = color;
      imageData.data[i*4+3] = 255;
    }
    const tmp = document.createElement('canvas');
    tmp.width = width;
    tmp.height = height;
    tmp.getContext('2d').putImageData(imageData,0,0);

    mapCtx.clearRect(0,0,canvasW,canvasH);
    mapCtx.drawImage(tmp, 0,0, canvasW, canvasH);

    document.getElementById('map-info').textContent = `Map ${width}x${height}, res=${resolution.toFixed(3)} m/px`;
    log('Received map, drawn.');
  } catch (e) {
    console.error(e);
    log('Error drawing map: ' + e);
  }
  drawMapPoints();
}

// --- โหลดจุดเมื่อเริ่มต้น ---
drawMapPoints();

/* ---------- Camera subscription ---------- */
const cameraImg = document.getElementById('camera-img');
const cameraTopicInput = document.getElementById('camera-topic');
const subscribeCameraBtn = document.getElementById('subscribe-camera');
let cameraSubscriber = null;

subscribeCameraBtn.addEventListener('click', ()=>{
  if (!ros) { log('ROS not connected'); return; }
  const topicName = cameraTopicInput.value.trim();
  if (!topicName) return;
  if (cameraSubscriber) cameraSubscriber.unsubscribe();
  cameraSubscriber = new ROSLIB.Topic({
    ros,
    name: topicName,
    messageType: topicName.includes('compressed') ? 'sensor_msgs/CompressedImage' : 'sensor_msgs/Image'
  });
  cameraSubscriber.subscribe(onCameraMessage);
  log('Subscribed to camera topic: ' + topicName);
});

function onCameraMessage(msg) {
  if (msg.data) {
    cameraImg.src = 'data:image/jpeg;base64,' + msg.data;
  }
}

/* ---------- Battery subscription ---------- */
function onBattery(msg) {
  let percent = null;
  if (typeof msg.percentage === 'number') {
    if (msg.percentage > 1.5) percent = msg.percentage.toFixed(1) + '%';
    else percent = (msg.percentage*100).toFixed(1) + '%';
  }
  else if (msg.voltage) percent = `${msg.voltage.toFixed(2)}V`;
  else percent = JSON.stringify(msg).slice(0,40);
  document.getElementById('battery').textContent = percent;
}

/* ---------- init UI ---------- */
renderGoals();
log('UI ready. Enter rosbridge ws url and press Connect.');
</script>
</body>
</html>
